[TOC]

# 08-01

### 1. 理解 `shouldComponentUpdate`

* React 虚拟 DOM 技术要求不断的将 DOM 和虚拟 DOM 进行 Diff 比较，如果 DOM 树比较大，这种比较操作就会比较耗时，因此 React 提供了 `shouldComponentUpdate` 这种补丁函数。对于一些变化，如果我们不希望某个组件刷新，或者刷新后跟原来一样，就可以使用这个函数直接告诉 React，省去 Diff 操作，进一步的提高了效率。

* 这个 React 生命周期钩子函数用来解决这个问题：

  在更新数据的时候用 `setState` 修改整个数据，数据变了之后，遍历的时候所有内容都 要被重新渲染，数据量少还好，数据量大就会严重影响性能

* 解决办法：

  1. `shouldcomponentupdate` 在渲染前判断组件是否更新，更新了再渲染
  2. `purecomponent`（纯组件）省去了虚拟 DOM 生成和对比的过程，在类组件中使用
  3. `react.memo()` 类似于纯组件，在无状态组件中使用



# 08-02

### 2. React `diff` 原理

* 基于三个策略： 

  1. tree diff

     Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计

  2. component diff

     拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件会生成不同的树形结构

  3. element diff

     对于同一层级的一组子节点，他们可以通过唯一的 ID 进行区分 何为受控组件

* React 负责渲染表单的组件，值是来自于 `state` 控制的，输入表单元素称为受控组件



# 08-03

### 3. Redux 中间件

* 中间件提供第三方插件的模式

  自定义拦截 action -> reducer 的过程，变为 action -> middlewares -> reducer

  这种机制可以让我们改变数据流，实现如异步 action，action 过滤，日志输出，异常报告等功能

* 常见的中间件

  1. redux-logger：提供日志输出
  2. redux-thunk：处理异步操作
  3. redux-promise：处理异步操作
  4. actionCreator 的返回值是 promisse



# 08-04

### 4. Redux 的缺点

* 一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 `store` 取
* 一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 `render`，可能会有效率影响，或者需要写复杂的 `shouldComponentUpdate` 进行判断



# 08-05

### 5. React 组件的划分

* 根据组件的职责通常把组件分为 UI 组件 和 容器组件
* UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑
* 两者通过 React-Redux 提供 `connect`  方法联系起来



# 08-06

### 6. React 性能优化是哪个周期函数

* `shouldComponentUpdate` 这个方法用来判断是否需要调用 `render` 方法重新描绘 DOM
* 因为 DOM 的描绘非常消耗性能，如果我们能在 `shouldComponentUpdate` 方法中写出更优化的 DOM Diff 算法，可以极大的提高性能优化



# 08-09

### 7. Diff 算法

* 把树形结构按照层级分解，只比较同级元素。
* 给列表结构的每个单元添加唯一的 `key` 属性，方便比较。
* React 只会匹配相同 `class` 的 `component`（这里面的 `class` 指的是组件的名字）。
* 合并操作。调用 `component` 的 `setState` 方法的时候，React 将其标记为 `dirty`，到每一个事件循环结束，React 检查所有标记 `dirty` 的 `component` 重新绘制。
* 选择性子树渲染。开发人员可以重写 `shouldComponentUpdate` 提高 Diff 的性能。



# 08-10

### 8. 简述 flux 思想

Flux 最大的特点，就是数据的 “单向流动”。 

1. 用户访问 View
2. View 发出用户的 Action
3. Dispatcher 收到 Action，要求 Store 进行相应的更新
4. Store 更新后，发出一个 `change` 事件
5. View 收到 `change` 事件后，更新页面



# 08-12

### 9. React 解决了什么问题

1. 组件复用
2. 性能
3. 兼容性



# 08-13

### 10. React 的协议

React 遵循的协议是 “BSD 许可证 + 专利开源协议”，这个协议比较奇葩，如果你的产品跟 facebook 没有竞争关系，你可以自由的使用 React，但是如果有竞争关系， 你的 React 的使用许可将会被取消。



# 08-14

### 11. React 的工作原理

React 会创建一个虚拟 DOM（Virtual DOM），当一个组件中的状态改变时，React 首先会通过 “diffing” 算法来标记虚拟 DOM 中的改变，第二步是调节（reconciliation）， 会用 Diff 的结果来更新 DOM。



# 08-15

### 12. 使用 React 有何优点

* 只需查看 `render` 函数就会很容易知道一个组件是如何被渲染的
*  JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的
* 支持服务端渲染，这可以改进 SEO 和性能
* 易于测试
* React 只关注 View 层，所以可以和其它任何框架（如 Backbone.js、Angular.js）一 起使用



# 08-16

### 13. 展示组件（Presentational component）和 容器组件（Container component）之间有何不同

* 展示组件 关心组件看起来是什么。

  展示专门通过 `props` 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。

* 容器组件 则更关心组件是如何运作的。

  容器组件会为展示组件或者其它容器组件提供数据和行为，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是（其它组件的）数据源。



# 08-18

### 14. 类组件（Class component）和 函数式组件（Functional component）之间有何不同

* 类组件 不仅允许你使用更多额外的功能，如 组件自身的状态和生命周期钩子，也能使组件直接访问 `store` 并维持状态。
* 当组件仅是接收 `props`，并将组件自身渲染到页面时，该组件就是一个 ”无状态组件（stateless component）“，可以使用一个纯函数来创建这样的组件。这种组件也被称为 哑组件（dumb components）或展示组件。



# 08-19

### 15.（组件的）状态（state）和 属性（props）之间有何不同

* State 是一种数据结构，用于组件挂载时所需数据的默认值。

  State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。

* Props( properties 的简写 ) 则是组件的配置。

  props 由父组件传递给子组件，并且就子组件而言，props 是不可变的。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起（统一管理）。props 也不仅仅是数据，回调函数也可以通过 props 传递。



# 08-20

### 16. 应该在 React 组件的何处发起 Ajax 请求

在 React 组件中，应该在 `componentDidMount` 中发起网络请求。

这个方法会在组件第一次 “挂载”（被添加到 DOM）时执行，在组件的生命周期中仅会执行一次。更重 要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 `setState`，这将不起作用。在 `componentDidMount` 中发起网络请求将保证这有一个组件可以更新了。



# 08-21

### 17. 使用箭头函数的优点是什么

* 作用域安全

  在箭头函数之前，每一个新创建的函数都有定义自身的 `this` 值（在构造函数中是新对象；在严格模式下，函数调用中的 `this` 是未定义的； 如果函数被称为 “对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 `this` 值。

* 简单

  箭头函数易于阅读和书写。

* 清晰

  当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 `next-higher` 函数语句，以查看 `this` 的值。



# 08-22

### 18. 当渲染一个列表时，何为 `key` ？设置 `key` 的目的是什么？

* `Keys` 会有助于 React 识别哪些 `items` 改变了，被添加了或者被移除了。

* `Keys` 应该被赋予数组内的元素以赋予（DOM）元素一个稳定的标识。

* 选择一个 `key` 的最佳方法是使用一个字符串，该字符串能唯一地标识一个列表项。

  很多时候你会使用数据中的 `IDs` 作为 `keys`；

  当你没有稳定的 `IDs` 用于被渲染的 `items` 时，可以使用项目索引作为渲染项的 `key`，但这种方式并不推荐，如果 `items` 可以重新排序，就会导致 re-render 变慢。



# 08-25

### 19. 如何定义需要一个 State

- 是否通过 `props` 从父组件获取
- 是否可以通过其他 `state` 和 `props` 计算得到
- 是否在 `render` 方法中使用



# 08-26

### 20. 如何修改 State

- 使用 `setState`
- `setState` 是异步的
- State 的更新是一个浅合并的过程