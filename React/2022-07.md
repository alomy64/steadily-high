[TOC]

# 07-02

### 1. 调用 `super(props)` 的目的

`Super()` 调用父类的构造方法，有 `super`，组件才有自己的 `this`，在组件全局中都可以使用 `this`，如果只是 `constructor` 而不执行 `super`，之后的 `this` 都是错的，`super` 继承父组件的 `this`



# 07-03

### 2. React 中构建组件的方式

* 自定义组件：函数组件或者无状态组件。组件首字母大写
* 类组件：一个类组件必须实现一个 `render` 方法，这个方法必须返回一个 jsx 元素，要用一个外层的元素把所有内容包裹起来



# 07-04

### 3. React 事件处理 —— 修改 `this` 指向

1. 通过 `bind` 方法进行原地绑定，从而改变 `this` 指向 
2. 通过创建箭头函数
3. 在 `constructor` 中提前对事件进行绑定
4. 将事件调用的写法改为箭头函数的形式



# 07-05

### 4. 调用 `setState` 之后发生了什么

1. React 在调用 `setstate` 后，会将传入的参数对象和组件当前的状态合并，触发调和过程

2. 在调和过程中，React 会根据新的状态构建 React 元素树，重新渲染整个 UI 界面，在得到元素树之后，会自动计算新老节点的差异，根据差异对界面进行最小化重新渲染



# 07-06

### 5. React 性能优化方案

1. 重写 `shouldComponentUpdate` 来避免不必要的 dom 操作
2. 使用 `production` 版本的 React.js
3. 使用 `key` 来帮助 React 识别列表中所有子组件的最小变化



# 07-09

### 6. 怎么阻止组件的渲染

在组件的 `render` 方法中返回 `null`，并不会影响触发组件的生命周期方法



# 07-15

### 7. 理解 JSX

* JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能
* JSX 生产 React ”元素“，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中
* 在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 `if` 语句和 `for` 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函 数中返回它



# 07-17

### 8. 在 React 中，refs 的作用

* `refs` 可以用于获取一个 DOM 节点或者 React 组件的引用
* 何时使用：管理焦点 / 文本选择，触发命令动画，或者和第三方 DOM 库集成
* 你应该避免使用 `String` 类型的 `refs` 和内联的 `ref` 回调，`refs` 回调是 React 所推荐的



# 07-18

### 9. 何为高阶组件（higher order component）

* 高阶组件是一个以组件为参数并返回一个新组件的函数。
* `HOC` 允许你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 `connect` 函数。
* 除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 `HOC`。



# 07-22

### 10. 为什么建议传递给 `setState` 的参数是一个 `callback` 而不是一个对象

因为 `this.props` 和 `this.state` 的更新可能是异步的，不能依赖它们的值去计算下一个 `state`。



# 07-23

### 11. 除了在构造函数中绑定 `this`，还有其它方式吗

可以使用属性初始值设定项（property initializers）来正确绑定回调，`create-react-app` 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。



# 07-24

### 12. 怎么阻止组件的渲染

在组件的 `render` 方法中返回 `null` 并不会影响触发组件的生命周期方法。



# 07-25

### 13.（在构造函数中）调用 `super(props)` 的目的是什么 

在 `super()` 被调用之前，子类是不能使用 `this` 的，在 ES2015 中，子类必须在 `constructor` 中调用 `super()`。传递 `props` 给 `super()` 的原因则是便于（在子类中）能在 `constructor` 访问 `this.props`。



# 07-26

### 14. angular 和 React 的区别

React 对比 Angular 是思想上的转变，它也并不是一个库，是一种开发理念，组件化， 分治的管理，数据与 view 的一体化。它只有一个中心，发出状态，渲染 view，对于虚 拟 dom 它并没有提高渲染页面的性能，它提供更多的是利用 jsx 便捷生成 dom 元素， 利用组件概念进行分治管理页面每个部分（例如 `header`、`section`、`footer`、`slider`）。



# 07-27

### 15. ajax VS fetch VS axios

* 传统 ajax 指的是 `XMLHttpRequest (XHR)`， 最早出现的发送后端请求技术，隶属 于原始 js 中，核心使用 `XMLHttpRequest` 对象，多个请求之间如果有先后关系的话， 就会出现回调地狱。JQuery ajax 是对原生 `XHR` 的封装
* fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 `XMLHttpRequest` 对象
* axios 是一个基于 `Promise` ，本质上也是对原生 `XHR` 的封装，只不过它是 `Promise` 的实现版本，符合最新的 ES 规范



# 07-28

### 16. react 组件之间的数据传递

* 正向传值用 `props`

* 逆向传值用函数传值

  通过事件调用函数传递

* 同级传值用 `pubsub-js`

* 用 `pubsub.publish`（事件名，数据）抛出数据

* 用 `pubsub.subscribe`（监听的事件，`() => {}`）接收数据

* 跨组件传递

  要使用 `context` 进行跨组件传值就需要使用 `createContext()` 方法，这个方法有两个对象：`provider`（生产者）和 `Consumer`（消费者）



# 07-29

### 17. 请简述虚拟 DOM与 Diff 算法

* 虚拟 DOM

  也就是常说的虚拟节点，它是通过 js 的 object 对象模拟 DOM 中的节点， 然后再通过特定的渲染方法将其渲染成真实的 DOM 节点。 

  频繁的操作 DOM，或大量造成页面的重绘和回流

* Diff 算法

  把树形结构按照层级分解，只比较同级元素，给列表结构的每个单元添加唯一的 key 值，方便比较你对组件的理解

  可组合，可复用，可维护，可测试



# 07-30

### 18. 为什么虚拟 DOM 会提高性能

* 虚拟 DOM 相当于在 js 和真实 DOM 中间加了一个缓存，利用 DOM Diff 算法避免了没有必要的 DOM 操作，从而提高性能。

* 具体实现步骤如下： 

  1. 用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树， 插到文档当中；

  2. 当状态变更的时候，重新构造一棵新的对象树，然后用新的树和旧的树进行比较， 记录两棵树的差异；
  3.  把 步骤2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。



# 07-31

### 19. 组件的 `state` 和 `props` 的区别

* `props` 是一个从外部传进组件的参数

  主要作用就是父组件向子组件传递数据，但是 `props` 对于使用它的组件来说是只读的，一旦赋值不能修改，只能通过外部组件主动传入新的 `props` 来重新渲染子组件 

* `state` 是一个组件的显示形态，可以由数据状态和外部参数决定，外部参数是 `props`，数据状态就是 `state`

  首先，在组件初始化的时候，用 `this.state` 给组件设定一个初始的 `state`，在第一次渲染的时候就会用这个数据来渲染组件

  `state` 不同于 `props` 的一点是， `state` 可以修改，通过 `this.setState()` 方法来修改 state